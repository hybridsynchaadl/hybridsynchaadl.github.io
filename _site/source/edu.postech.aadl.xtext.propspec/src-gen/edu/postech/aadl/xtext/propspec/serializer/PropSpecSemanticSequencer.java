/*
 * generated by Xtext
 */
package edu.postech.aadl.xtext.propspec.serializer;

import com.google.inject.Inject;
import edu.postech.aadl.xtext.propspec.propSpec.BinaryExpression;
import edu.postech.aadl.xtext.propspec.propSpec.Invariant;
import edu.postech.aadl.xtext.propspec.propSpec.PropRef;
import edu.postech.aadl.xtext.propspec.propSpec.PropSpecPackage;
import edu.postech.aadl.xtext.propspec.propSpec.Proposition;
import edu.postech.aadl.xtext.propspec.propSpec.RANDOM;
import edu.postech.aadl.xtext.propspec.propSpec.Reachability;
import edu.postech.aadl.xtext.propspec.propSpec.SYMBOLIC;
import edu.postech.aadl.xtext.propspec.propSpec.ScopedExpression;
import edu.postech.aadl.xtext.propspec.propSpec.Top;
import edu.postech.aadl.xtext.propspec.propSpec.UnaryExpression;
import edu.postech.aadl.xtext.propspec.propSpec.Value;
import edu.postech.aadl.xtext.propspec.services.PropSpecGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.osate.aadl2.Aadl2Package;
import org.osate.aadl2.ArrayRange;
import org.osate.aadl2.BasicPropertyAssociation;
import org.osate.aadl2.BooleanLiteral;
import org.osate.aadl2.ClassifierValue;
import org.osate.aadl2.ComputedValue;
import org.osate.aadl2.ContainedNamedElement;
import org.osate.aadl2.ContainmentPathElement;
import org.osate.aadl2.IntegerLiteral;
import org.osate.aadl2.ListValue;
import org.osate.aadl2.ModalPropertyValue;
import org.osate.aadl2.NamedValue;
import org.osate.aadl2.Operation;
import org.osate.aadl2.PropertyAssociation;
import org.osate.aadl2.RangeValue;
import org.osate.aadl2.RealLiteral;
import org.osate.aadl2.RecordValue;
import org.osate.aadl2.ReferenceValue;
import org.osate.aadl2.StringLiteral;
import org.osate.xtext.aadl2.properties.serializer.PropertiesSemanticSequencer;

@SuppressWarnings("all")
public class PropSpecSemanticSequencer extends PropertiesSemanticSequencer {

	@Inject
	private PropSpecGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == Aadl2Package.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Aadl2Package.ARRAY_RANGE:
				sequence_ArrayRange(context, (ArrayRange) semanticObject); 
				return; 
			case Aadl2Package.BASIC_PROPERTY_ASSOCIATION:
				sequence_FieldPropertyAssociation(context, (BasicPropertyAssociation) semanticObject); 
				return; 
			case Aadl2Package.BOOLEAN_LITERAL:
				sequence_BooleanLiteral(context, (BooleanLiteral) semanticObject); 
				return; 
			case Aadl2Package.CLASSIFIER_VALUE:
				sequence_ComponentClassifierTerm(context, (ClassifierValue) semanticObject); 
				return; 
			case Aadl2Package.COMPUTED_VALUE:
				sequence_ComputedTerm(context, (ComputedValue) semanticObject); 
				return; 
			case Aadl2Package.CONTAINED_NAMED_ELEMENT:
				sequence_ContainmentPath(context, (ContainedNamedElement) semanticObject); 
				return; 
			case Aadl2Package.CONTAINMENT_PATH_ELEMENT:
				sequence_ContainmentPathElement(context, (ContainmentPathElement) semanticObject); 
				return; 
			case Aadl2Package.INTEGER_LITERAL:
				if (rule == grammarAccess.getPropertyExpressionRule()
						|| rule == grammarAccess.getIntegerTermRule()
						|| rule == grammarAccess.getNumAltRule()) {
					sequence_IntegerTerm(context, (IntegerLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getValueConstantRule()
						|| rule == grammarAccess.getUnsignedIntegerTermRule()) {
					sequence_UnsignedIntegerTerm(context, (IntegerLiteral) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.LIST_VALUE:
				sequence_ListTerm(context, (ListValue) semanticObject); 
				return; 
			case Aadl2Package.MODAL_PROPERTY_VALUE:
				if (rule == grammarAccess.getModalPropertyValueRule()) {
					sequence_ModalPropertyValue(context, (ModalPropertyValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOptionalModalPropertyValueRule()) {
					sequence_OptionalModalPropertyValue(context, (ModalPropertyValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertyValueRule()) {
					sequence_PropertyValue(context, (ModalPropertyValue) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.NAMED_VALUE:
				if (rule == grammarAccess.getConstantValueRule()
						|| rule == grammarAccess.getNumAltRule()) {
					sequence_ConstantValue(context, (NamedValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertyExpressionRule()
						|| rule == grammarAccess.getLiteralorReferenceTermRule()) {
					sequence_LiteralorReferenceTerm(context, (NamedValue) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.OPERATION:
				sequence_SignedConstant(context, (Operation) semanticObject); 
				return; 
			case Aadl2Package.PROPERTY_ASSOCIATION:
				if (rule == grammarAccess.getBasicPropertyAssociationRule()) {
					sequence_BasicPropertyAssociation(context, (PropertyAssociation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPModelRule()
						|| rule == grammarAccess.getContainedPropertyAssociationRule()) {
					sequence_ContainedPropertyAssociation(context, (PropertyAssociation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertyAssociationRule()) {
					sequence_PropertyAssociation(context, (PropertyAssociation) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.RANGE_VALUE:
				sequence_NumericRangeTerm(context, (RangeValue) semanticObject); 
				return; 
			case Aadl2Package.REAL_LITERAL:
				if (rule == grammarAccess.getPropertyExpressionRule()
						|| rule == grammarAccess.getRealTermRule()
						|| rule == grammarAccess.getNumAltRule()) {
					sequence_RealTerm(context, (RealLiteral) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getValueConstantRule()
						|| rule == grammarAccess.getUnsignedRealTermRule()) {
					sequence_UnsignedRealTerm(context, (RealLiteral) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.RECORD_VALUE:
				if (rule == grammarAccess.getOldRecordTermRule()) {
					sequence_OldRecordTerm(context, (RecordValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertyExpressionRule()
						|| rule == grammarAccess.getRecordTermRule()) {
					sequence_RecordTerm(context, (RecordValue) semanticObject); 
					return; 
				}
				else break;
			case Aadl2Package.REFERENCE_VALUE:
				sequence_ReferenceTerm(context, (ReferenceValue) semanticObject); 
				return; 
			case Aadl2Package.STRING_LITERAL:
				sequence_StringTerm(context, (StringLiteral) semanticObject); 
				return; 
			}
		else if (epackage == PropSpecPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case PropSpecPackage.BINARY_EXPRESSION:
				if (action == grammarAccess.getPSExpressionAccess().getBinaryExpressionLeftAction_0_1_0()) {
					sequence_PSExpression_BinaryExpression_0_1_0(context, (BinaryExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPSExpressionRule()
						|| action == grammarAccess.getPSExpressionAccess().getBinaryExpressionLeftAction_1_1_0()
						|| rule == grammarAccess.getRelationRule()
						|| action == grammarAccess.getRelationAccess().getBinaryExpressionLeftAction_0_1_0()
						|| rule == grammarAccess.getModifiedExpressionRule()
						|| rule == grammarAccess.getSimpleExpressionRule()
						|| action == grammarAccess.getSimpleExpressionAccess().getBinaryExpressionLeftAction_1_0()
						|| rule == grammarAccess.getTermRule()
						|| action == grammarAccess.getTermAccess().getBinaryExpressionLeftAction_0_1_0()
						|| rule == grammarAccess.getValueRule()) {
					sequence_PSExpression_Relation_SimpleExpression_Term(context, (BinaryExpression) semanticObject); 
					return; 
				}
				else break;
			case PropSpecPackage.INVARIANT:
				sequence_Invariant(context, (Invariant) semanticObject); 
				return; 
			case PropSpecPackage.PROP_REF:
				sequence_PropRef(context, (PropRef) semanticObject); 
				return; 
			case PropSpecPackage.PROPOSITION:
				sequence_Proposition(context, (Proposition) semanticObject); 
				return; 
			case PropSpecPackage.RANDOM:
				sequence_RANDOM(context, (RANDOM) semanticObject); 
				return; 
			case PropSpecPackage.REACHABILITY:
				sequence_Reachability(context, (Reachability) semanticObject); 
				return; 
			case PropSpecPackage.SYMBOLIC:
				sequence_SYMBOLIC(context, (SYMBOLIC) semanticObject); 
				return; 
			case PropSpecPackage.SCOPED_EXPRESSION:
				sequence_ScopedExpression(context, (ScopedExpression) semanticObject); 
				return; 
			case PropSpecPackage.TOP:
				sequence_Top(context, (Top) semanticObject); 
				return; 
			case PropSpecPackage.UNARY_EXPRESSION:
				sequence_ModifiedExpression_Term(context, (UnaryExpression) semanticObject); 
				return; 
			case PropSpecPackage.VALUE:
				sequence_Value(context, (Value) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Property returns Invariant
	 *     Invariant returns Invariant
	 *
	 * Constraint:
	 *     (name=ID initCond=PSExpression? goalCond=PSExpression bound=INTVALUE)
	 */
	protected void sequence_Invariant(ISerializationContext context, Invariant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PSExpression returns UnaryExpression
	 *     PSExpression.BinaryExpression_1_1_0 returns UnaryExpression
	 *     Relation returns UnaryExpression
	 *     Relation.BinaryExpression_0_1_0 returns UnaryExpression
	 *     ModifiedExpression returns UnaryExpression
	 *     SimpleExpression returns UnaryExpression
	 *     SimpleExpression.BinaryExpression_1_0 returns UnaryExpression
	 *     Term returns UnaryExpression
	 *     Term.BinaryExpression_0_1_0 returns UnaryExpression
	 *     Value returns UnaryExpression
	 *
	 * Constraint:
	 *     (((op='+' | op='-') child=SimpleExpression) | ((op='abs' | op='not') child=Value))
	 */
	protected void sequence_ModifiedExpression_Term(ISerializationContext context, UnaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PSExpression.BinaryExpression_0_1_0 returns BinaryExpression
	 *
	 * Constraint:
	 *     (left=PSExpression_BinaryExpression_0_1_0 (op='and' | op='or' | op='xor') right=PSExpression)
	 */
	protected void sequence_PSExpression_BinaryExpression_0_1_0(ISerializationContext context, BinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PSExpression returns BinaryExpression
	 *     PSExpression.BinaryExpression_1_1_0 returns BinaryExpression
	 *     Relation returns BinaryExpression
	 *     Relation.BinaryExpression_0_1_0 returns BinaryExpression
	 *     ModifiedExpression returns BinaryExpression
	 *     SimpleExpression returns BinaryExpression
	 *     SimpleExpression.BinaryExpression_1_0 returns BinaryExpression
	 *     Term returns BinaryExpression
	 *     Term.BinaryExpression_0_1_0 returns BinaryExpression
	 *     Value returns BinaryExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=PSExpression_BinaryExpression_0_1_0 (op='and' | op='or' | op='xor') right=PSExpression) | 
	 *         (left=PSExpression_BinaryExpression_1_1_0 (op='and' | op='or' | op='xor') right=Relation) | 
	 *         (
	 *             left=Relation_BinaryExpression_0_1_0 
	 *             (
	 *                 op='=' | 
	 *                 op='!=' | 
	 *                 op='<' | 
	 *                 op='<=' | 
	 *                 op='>' | 
	 *                 op='>='
	 *             ) 
	 *             right=ModifiedExpression
	 *         ) | 
	 *         (left=SimpleExpression_BinaryExpression_1_0 (op='+' | op='-') right=Term) | 
	 *         (left=Term_BinaryExpression_0_1_0 (op='*' | op='/') right=Value)
	 *     )
	 */
	protected void sequence_PSExpression_Relation_SimpleExpression_Term(ISerializationContext context, BinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PSExpression returns PropRef
	 *     PSExpression.BinaryExpression_1_1_0 returns PropRef
	 *     Relation returns PropRef
	 *     Relation.BinaryExpression_0_1_0 returns PropRef
	 *     ModifiedExpression returns PropRef
	 *     SimpleExpression returns PropRef
	 *     SimpleExpression.BinaryExpression_1_0 returns PropRef
	 *     Term returns PropRef
	 *     Term.BinaryExpression_0_1_0 returns PropRef
	 *     Value returns PropRef
	 *     PropRef returns PropRef
	 *
	 * Constraint:
	 *     def=[Proposition|ID]
	 */
	protected void sequence_PropRef(ISerializationContext context, PropRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PropSpecPackage.Literals.PROP_REF__DEF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PropSpecPackage.Literals.PROP_REF__DEF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPropRefAccess().getDefPropositionIDTerminalRuleCall_0_1(), semanticObject.eGet(PropSpecPackage.Literals.PROP_REF__DEF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Proposition returns Proposition
	 *
	 * Constraint:
	 *     (name=ID expression=PSExpression)
	 */
	protected void sequence_Proposition(ISerializationContext context, Proposition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PropSpecPackage.Literals.PROPOSITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PropSpecPackage.Literals.PROPOSITION__NAME));
			if (transientValues.isValueTransient(semanticObject, PropSpecPackage.Literals.PROPOSITION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PropSpecPackage.Literals.PROPOSITION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPropositionAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPropositionAccess().getExpressionPSExpressionParserRuleCall_5_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Mode returns RANDOM
	 *     RANDOM returns RANDOM
	 *
	 * Constraint:
	 *     (name='random' seed=INTVALUE)
	 */
	protected void sequence_RANDOM(ISerializationContext context, RANDOM semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PropSpecPackage.Literals.MODE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PropSpecPackage.Literals.MODE__NAME));
			if (transientValues.isValueTransient(semanticObject, PropSpecPackage.Literals.RANDOM__SEED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PropSpecPackage.Literals.RANDOM__SEED));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRANDOMAccess().getNameRandomKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getRANDOMAccess().getSeedINTVALUEParserRuleCall_2_0(), semanticObject.getSeed());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Property returns Reachability
	 *     Reachability returns Reachability
	 *
	 * Constraint:
	 *     (name=ID initCond=PSExpression? goalCond=PSExpression bound=INTVALUE)
	 */
	protected void sequence_Reachability(ISerializationContext context, Reachability semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Mode returns SYMBOLIC
	 *     SYMBOLIC returns SYMBOLIC
	 *
	 * Constraint:
	 *     name='symbolic'
	 */
	protected void sequence_SYMBOLIC(ISerializationContext context, SYMBOLIC semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PropSpecPackage.Literals.MODE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PropSpecPackage.Literals.MODE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSYMBOLICAccess().getNameSymbolicKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PSExpression returns ScopedExpression
	 *     PSExpression.BinaryExpression_0_1_0 returns ScopedExpression
	 *     PSExpression.BinaryExpression_1_1_0 returns ScopedExpression
	 *     Relation returns ScopedExpression
	 *     Relation.BinaryExpression_0_1_0 returns ScopedExpression
	 *     ModifiedExpression returns ScopedExpression
	 *     SimpleExpression returns ScopedExpression
	 *     SimpleExpression.BinaryExpression_1_0 returns ScopedExpression
	 *     Term returns ScopedExpression
	 *     Term.BinaryExpression_0_1_0 returns ScopedExpression
	 *     Value returns ScopedExpression
	 *     ScopedExpression returns ScopedExpression
	 *
	 * Constraint:
	 *     (path=ContainmentPath expression=PSExpression)
	 */
	protected void sequence_ScopedExpression(ISerializationContext context, ScopedExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PropSpecPackage.Literals.SCOPED_EXPRESSION__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PropSpecPackage.Literals.SCOPED_EXPRESSION__PATH));
			if (transientValues.isValueTransient(semanticObject, PropSpecPackage.Literals.SCOPED_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PropSpecPackage.Literals.SCOPED_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScopedExpressionAccess().getPathContainmentPathParserRuleCall_0_0(), semanticObject.getPath());
		feeder.accept(grammarAccess.getScopedExpressionAccess().getExpressionPSExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Top returns Top
	 *
	 * Constraint:
	 *     (name=ID | model=[ComponentClassifier|QCREF] | path=STRING | proposition+=Proposition | property+=Property)+
	 */
	protected void sequence_Top(ISerializationContext context, Top semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ValueConstant returns IntegerLiteral
	 *     UnsignedIntegerTerm returns IntegerLiteral
	 *
	 * Constraint:
	 *     (value=UnsignedInt unit=[UnitLiteral|ID]?)
	 */
	protected void sequence_UnsignedIntegerTerm(ISerializationContext context, IntegerLiteral semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ValueConstant returns RealLiteral
	 *     UnsignedRealTerm returns RealLiteral
	 *
	 * Constraint:
	 *     (value=UnsignedReal unit=[UnitLiteral|ID]?)
	 */
	protected void sequence_UnsignedRealTerm(ISerializationContext context, RealLiteral semanticObject) {
		genericSequencer.createSequence(context, (EObject) semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PSExpression returns Value
	 *     PSExpression.BinaryExpression_1_1_0 returns Value
	 *     Relation returns Value
	 *     Relation.BinaryExpression_0_1_0 returns Value
	 *     ModifiedExpression returns Value
	 *     SimpleExpression returns Value
	 *     SimpleExpression.BinaryExpression_1_0 returns Value
	 *     Term returns Value
	 *     Term.BinaryExpression_0_1_0 returns Value
	 *     Value returns Value
	 *
	 * Constraint:
	 *     (value=ValueConstant | value=ContainmentPath)
	 */
	protected void sequence_Value(ISerializationContext context, Value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
