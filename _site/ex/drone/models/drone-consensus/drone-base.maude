
fmod PAIR{X :: TRIV, Y :: TRIV} is
  sort Pair{X, Y} .

  op <_;_> : X$Elt Y$Elt -> Pair{X, Y} .
  op 1st : Pair{X, Y} -> X$Elt .
  op 2nd : Pair{X, Y} -> Y$Elt .

  var A : X$Elt .
  var B : Y$Elt .

  eq 1st(< A ; B >) = A .
  eq 2nd(< A ; B >) = B .

endfm

fmod RAT-INF is
  protecting RAT .

  sort RatInf .
  subsort Rat < RatInf .
  op inf : -> RatInf [ctor] .

  var R  : Rat .
  var RI : RatInf .

  eq inf <  R   = false .
  eq inf <= R   = false .
  eq inf >  R   = true .
  eq inf >= R   = true .
  eq R   <  inf = true  .
  eq R   <= inf = true  .
  eq R   >  inf = false  .
  eq R   >= inf = false  .

  eq RI + inf = inf .

  eq max(inf, R) = inf .
  eq min(inf, R) = R .

  var I : Int .

  --- hard coded sin/cos function
  ops sin cos : Int -> Rat .
  eq sin(0) = 0 .
  eq sin(45) = 707106781186547 / 1000000000000000 .
  eq sin(90) = 1 .
  eq sin(135) = sin(45) .
  eq sin(180) = sin(0) .
  ceq sin(I) = - sin(I - 180) if I > 180 .
  ceq sin(I) = sin(360 + I) if I < 0 .

  eq cos(I) = sin(90 - I) .

endfm

fmod NONNEG-RAT is
  protecting RAT .

  sort NNegRat .                 --- non-negative rationals!
  subsorts Zero PosRat Nat < NNegRat < Rat .
endfm


fmod TIME is
  including NONNEG-RAT .
  protecting RAT-INF .

  sort Time .
  subsort NNegRat RatInf < Time .
endfm


fmod VECTOR is
  including RAT .

  sort Vector .
  op [_,_,_] : Rat Rat Rat -> Vector [ctor] .

  vars X1 Y1 Z1 X2 Y2 Z2 A : Rat .
  var IN T O : Rat .


  --- binary
  ops _+_ _-_ : Vector Vector -> Vector [prec 33] .
  eq [X1,Y1,Z1] + [X2,Y2,Z2] = [X1 + X2, Y1 + Y2, Z1 + Z2] .
  eq [X1,Y1,Z1] - [X2,Y2,Z2] = [X1 - X2, Y1 - Y2, Z1 - Z2] .

  op _/_ : Vector Vector -> Rat .
  ceq [X1,Y1,Z1] / [X2,Y2,Z2] = (X1 / X2)
    if (X1 / X2) == (Y1 / Y2) /\ (X1 / X2) == (Z1 / Z2) .

  --- scalar
  op _*_ : Rat Vector -> Vector [gather (e E) prec 31].
  eq A * [X1,Y1,Z1] = [A * X1, A * Y1, A * Z1] .

  --- magnitude
  op |_| : Vector -> Rat .
  eq | [X1,Y1,Z1] | = babylon((X1 * X1) + (Y1 * Y1) + (Z1 * Z1), 1/1, 10) .

  op babylon : Rat Rat Rat -> Rat .
  ceq babylon(IN,O,T) = babylon(IN, ((O + (IN / O)) / (2/1)), (T - 1)) if T >= 1 .
  eq babylon(IN,O,T) = O [owise] .

  --- direction
  op unitDir : Vector -> Vector .
  eq unitDir([X1, Y1, Z1]) = [unit(X1), unit(Y1), unit(Z1)] .

  op unit : Rat -> Rat .
  ceq unit(X1) = 1 if X1 > 0 .
  ceq unit(X1) = -1 if X1 < 0 .
  eq unit(0) = 0 .


  --- calculate angle
  op 2D-angle : Vector -> Nat .
  eq 2D-angle([0, 0, Z1]) = 0 .
  eq 2D-angle([1, 0, Z1]) = 0 .
  eq 2D-angle([1, 1, Z1]) = 45 .
  eq 2D-angle([1, 0, Z1]) = 90 .
  eq 2D-angle([-1, 1, Z1]) = 135 .
  eq 2D-angle([-1, 0, Z1]) = 180 .
  eq 2D-angle([-1, -1, Z1]) = 225 .
  eq 2D-angle([0, -1, Z1]) = 270 .
  eq 2D-angle([1, -1, Z1]) = 315 .

endfm

view Vector from TRIV to VECTOR is
    sort Elt to Vector .
endv

view Oid from TRIV to CONFIGURATION is
    sort Elt to Oid .
endv

mod OID-SET is
  protecting SET{Oid} * (sort Set{Oid} to OidSet,
                 op _`,_ to _;_) .
endm

mod INFO-STATE is
  protecting PAIR{Vector,Vector} .
endm

mod SYSTEM is
  including CONFIGURATION .

  sort Sys .
  op {_} : Configuration -> Sys .

endm
