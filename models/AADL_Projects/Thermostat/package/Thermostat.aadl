package Thermostat
public
	with Base_Types;
	with Data_Model;

	system Thermostat
		features
			on_control: out event port;
			off_control: out event port;
			power : out data port Base_Types::Float {Data_Model::Initial_Value => ("0");};
			t_out : out data port Base_Types::Float {Data_Model::Initial_Value => ("0");};
			t_in: in data port Base_Types::Float;
			curr_temp : in data port Base_Types::Float;
	end Thermostat; 

	system implementation Thermostat.simple
		subcomponents
			ctrlProc: process ThermostatProc.simple;
		connections
			O1: port ctrlProc.on_control -> on_control; 
			O2: port ctrlProc.off_control -> off_control;
			O3: port ctrlProc.power -> power;
			O4: port ctrlProc.t_out -> t_out;
			I1: port t_in -> ctrlProc.t_in;
			I2: port curr_temp -> ctrlProc.curr_temp;	
	end Thermostat.simple;
	
	system implementation Thermostat.complex extends Thermostat.simple
		subcomponents
			ctrlProc: refined to process ThermostatProc.complex;
	end Thermostat.complex;

	process ThermostatProc
		features
			on_control: out event port;
			off_control: out event port;
			power : out data port Base_Types::Float;
			t_out : out data port Base_Types::Float;
			t_in: in data port Base_Types::Float;
			curr_temp : in data port Base_Types::Float;
	end ThermostatProc;

	process implementation ThermostatProc.simple
		subcomponents
			ctrlThread: thread ThermostatThread.simple;
		connections
			O1: port ctrlThread.on_control -> on_control;
			O2: port ctrlThread.off_control -> off_control;
			O3: port ctrlThread.power -> power;
			O4: port ctrlThread.t_out -> t_out;
			I1: port t_in -> ctrlThread.t_in;
			I2: port curr_temp -> ctrlThread.curr_temp;	
	end ThermostatProc.simple;
	
	process implementation ThermostatProc.complex extends ThermostatProc.simple
		subcomponents
			ctrlThread: refined to thread ThermostatThread.complex;
	end ThermostatProc.complex;

	thread ThermostatThread
		features
			on_control: out event port;
			off_control: out event port;
			power : out data port Base_Types::Float;
			t_out : out data port Base_Types::Float;
			t_in: in data port Base_Types::Float;
			curr_temp : in data port Base_Types::Float;
		properties
			Dispatch_Protocol => Periodic;
	end ThermostatThread;

thread implementation ThermostatThread.simple
  annex behavior_specification{**
    variables
          a : Base_Types::Float;
    states
      init : initial complete state;
      exec : state;
    transitions
      init -[ on dispatch ]-> exec {
        t_out := curr_temp
      };

      exec -[ true ]-> init {
        a := -(curr_temp - t_in);
        if(a > 10){
            power := 5;
            on_control!
        }
        elsif(a > 3){
            power := 3;
            on_control!
        }
        else{
            power := 0;
            off_control!
        }
        end if
      };
  **};
end ThermostatThread.simple;


thread implementation ThermostatThread.complex extends ThermostatThread.simple
	  annex behavior_specification{**
  	variables
  	  a : Base_Types::Float;
    states
      init : initial complete state;
      exec : state;
    transitions
      init -[ on dispatch ]-> exec {
      	t_out := curr_temp	
      };
      
      exec -[ curr_temp > 50 ]-> init {
      	off_control!;
      	power := 0
      };
      
      exec -[ curr_temp < 20 ]-> init {
      	on_control!;
      	power := 10
      };
      
      exec -[ otherwise ]-> init {
      	a := -(curr_temp - t_in);
      	      	
      	if(a > 10){
      		power := 5;
      		on_control!
      	}
      	elsif(a > 5){
      		power := 4;
      		on_control!
      	}
      	elsif(a > 3){
      		power := 3;
      		on_control!
      	}
      	elsif(a > 0){
      		power := 2;
      		on_control!
      	}
      	else{
      		power := 0;
      		off_control!
      	}
      	end if
      };
  **};
end ThermostatThread.complex;

end Thermostat;
